(!globalThis.EventTarget||!globalThis.Event)&&console.error(`
  PartySocket requires a global 'EventTarget' class to be available!
  You can polyfill this global by adding this to your code before any partysocket imports: 
  
  \`\`\`
  import 'partysocket/event-target-polyfill';
  \`\`\`
  Please file an issue at https://github.com/partykit/partykit if you're still having trouble.
`);var E=class extends Event{message;error;constructor(t,e){super("error",e),this.message=t.message,this.error=t}},x=class extends Event{code;reason;wasClean=!0;constructor(t=1e3,e="",s){super("close",s),this.code=t,this.reason=e}},m={Event,ErrorEvent:E,CloseEvent:x};function L(t,e){if(!t)throw new Error(e)}function O(t){return new t.constructor(t.type,t)}function W(t){return"data"in t?new MessageEvent(t.type,t):"code"in t||"reason"in t?new x(t.code||1999,t.reason||"unknown reason",t):"error"in t?new E(t.error,t):new Event(t.type,t)}var N=typeof process<"u"&&typeof process.versions?.node<"u"&&typeof document>"u",d=N?W:O,c={maxReconnectionDelay:1e4,minReconnectionDelay:1e3+Math.random()*4e3,minUptime:5e3,reconnectionDelayGrowFactor:1.3,connectionTimeout:4e3,maxRetries:1/0,maxEnqueuedMessages:1/0,startClosed:!1,debug:!1},v=!1,f=class a extends EventTarget{_ws;_retryCount=-1;_uptimeTimeout;_connectTimeout;_shouldReconnect=!0;_connectLock=!1;_binaryType="blob";_closeCalled=!1;_messageQueue=[];_debugLogger=console.log.bind(console);_url;_protocols;_options;constructor(e,s,o={}){super(),this._url=e,this._protocols=s,this._options=o,this._options.startClosed&&(this._shouldReconnect=!1),this._options.debugLogger&&(this._debugLogger=this._options.debugLogger),this._connect()}static get CONNECTING(){return 0}static get OPEN(){return 1}static get CLOSING(){return 2}static get CLOSED(){return 3}get CONNECTING(){return a.CONNECTING}get OPEN(){return a.OPEN}get CLOSING(){return a.CLOSING}get CLOSED(){return a.CLOSED}get binaryType(){return this._ws?this._ws.binaryType:this._binaryType}set binaryType(e){this._binaryType=e,this._ws&&(this._ws.binaryType=e)}get retryCount(){return Math.max(this._retryCount,0)}get bufferedAmount(){return this._messageQueue.reduce((s,o)=>(typeof o=="string"?s+=o.length:o instanceof Blob?s+=o.size:s+=o.byteLength,s),0)+(this._ws?this._ws.bufferedAmount:0)}get extensions(){return this._ws?this._ws.extensions:""}get protocol(){return this._ws?this._ws.protocol:""}get readyState(){return this._ws?this._ws.readyState:this._options.startClosed?a.CLOSED:a.CONNECTING}get url(){return this._ws?this._ws.url:""}get shouldReconnect(){return this._shouldReconnect}onclose=null;onerror=null;onmessage=null;onopen=null;close(e=1e3,s){if(this._closeCalled=!0,this._shouldReconnect=!1,this._clearTimeouts(),!this._ws){this._debug("close enqueued: no ws instance");return}if(this._ws.readyState===this.CLOSED){this._debug("close: already closed");return}this._ws.close(e,s)}reconnect(e,s){this._shouldReconnect=!0,this._closeCalled=!1,this._retryCount=-1,!this._ws||this._ws.readyState===this.CLOSED?this._connect():(this._disconnect(e,s),this._connect())}send(e){if(this._ws&&this._ws.readyState===this.OPEN)this._debug("send",e),this._ws.send(e);else{let{maxEnqueuedMessages:s=c.maxEnqueuedMessages}=this._options;this._messageQueue.length<s&&(this._debug("enqueue",e),this._messageQueue.push(e))}}_debug(...e){this._options.debug&&this._debugLogger("RWS>",...e)}_getNextDelay(){let{reconnectionDelayGrowFactor:e=c.reconnectionDelayGrowFactor,minReconnectionDelay:s=c.minReconnectionDelay,maxReconnectionDelay:o=c.maxReconnectionDelay}=this._options,r=0;return this._retryCount>0&&(r=s*Math.pow(e,this._retryCount-1),r>o&&(r=o)),this._debug("next delay",r),r}_wait(){return new Promise(e=>{setTimeout(e,this._getNextDelay())})}_getNextProtocols(e){if(!e)return Promise.resolve(null);if(typeof e=="string"||Array.isArray(e))return Promise.resolve(e);if(typeof e=="function"){let s=e();if(!s)return Promise.resolve(null);if(typeof s=="string"||Array.isArray(s))return Promise.resolve(s);if(s.then)return s}throw Error("Invalid protocols")}_getNextUrl(e){if(typeof e=="string")return Promise.resolve(e);if(typeof e=="function"){let s=e();if(typeof s=="string")return Promise.resolve(s);if(s.then)return s}throw Error("Invalid URL")}_connect(){if(this._connectLock||!this._shouldReconnect)return;this._connectLock=!0;let{maxRetries:e=c.maxRetries,connectionTimeout:s=c.connectionTimeout}=this._options;if(this._retryCount>=e){this._debug("max retries reached",this._retryCount,">=",e);return}this._retryCount++,this._debug("connect",this._retryCount),this._removeListeners(),this._wait().then(()=>Promise.all([this._getNextUrl(this._url),this._getNextProtocols(this._protocols||null)])).then(([o,r])=>{if(this._closeCalled){this._connectLock=!1;return}!this._options.WebSocket&&typeof WebSocket>"u"&&!v&&(console.error(`\u203C\uFE0F No WebSocket implementation available. You should define options.WebSocket. 

For example, if you're using node.js, run \`npm install ws\`, and then in your code:

import PartySocket from 'partysocket';
import WS from 'ws';

const partysocket = new PartySocket({
  host: "127.0.0.1:1999",
  room: "test-room",
  WebSocket: WS
});

`),v=!0);let h=this._options.WebSocket||WebSocket;this._debug("connect",{url:o,protocols:r}),this._ws=r?new h(o,r):new h(o),this._ws.binaryType=this._binaryType,this._connectLock=!1,this._addListeners(),this._connectTimeout=setTimeout(()=>this._handleTimeout(),s)}).catch(o=>{this._connectLock=!1,this._handleError(new m.ErrorEvent(Error(o.message),this))})}_handleTimeout(){this._debug("timeout event"),this._handleError(new m.ErrorEvent(Error("TIMEOUT"),this))}_disconnect(e=1e3,s){if(this._clearTimeouts(),!!this._ws){this._removeListeners();try{this._ws.close(e,s),this._handleClose(new m.CloseEvent(e,s,this))}catch{}}}_acceptOpen(){this._debug("accept open"),this._retryCount=0}_handleOpen=e=>{this._debug("open event");let{minUptime:s=c.minUptime}=this._options;clearTimeout(this._connectTimeout),this._uptimeTimeout=setTimeout(()=>this._acceptOpen(),s),L(this._ws,"WebSocket is not defined"),this._ws.binaryType=this._binaryType,this._messageQueue.forEach(o=>this._ws?.send(o)),this._messageQueue=[],this.onopen&&this.onopen(e),this.dispatchEvent(d(e))};_handleMessage=e=>{this._debug("message event"),this.onmessage&&this.onmessage(e),this.dispatchEvent(d(e))};_handleError=e=>{this._debug("error event",e.message),this._disconnect(void 0,e.message==="TIMEOUT"?"timeout":void 0),this.onerror&&this.onerror(e),this._debug("exec error listeners"),this.dispatchEvent(d(e)),this._connect()};_handleClose=e=>{this._debug("close event"),this._clearTimeouts(),this._shouldReconnect&&this._connect(),this.onclose&&this.onclose(e),this.dispatchEvent(d(e))};_removeListeners(){this._ws&&(this._debug("removeListeners"),this._ws.removeEventListener("open",this._handleOpen),this._ws.removeEventListener("close",this._handleClose),this._ws.removeEventListener("message",this._handleMessage),this._ws.removeEventListener("error",this._handleError))}_addListeners(){this._ws&&(this._debug("addListeners"),this._ws.addEventListener("open",this._handleOpen),this._ws.addEventListener("close",this._handleClose),this._ws.addEventListener("message",this._handleMessage),this._ws.addEventListener("error",this._handleError))}_clearTimeouts(){clearTimeout(this._connectTimeout),clearTimeout(this._uptimeTimeout)}};var P=t=>t[1]!==null&&t[1]!==void 0;function R(){if(typeof crypto<"u"&&crypto.randomUUID)return crypto.randomUUID();let t=new Date().getTime(),e=typeof performance<"u"&&performance.now&&performance.now()*1e3||0;return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(s){let o=Math.random()*16;return t>0?(o=(t+o)%16|0,t=Math.floor(t/16)):(o=(e+o)%16|0,e=Math.floor(e/16)),(s==="x"?o:o&3|8).toString(16)})}function k(t,e,s={}){let{host:o,path:r,protocol:h,room:u,party:_,query:l}=t,n=o.replace(/^(http|https|ws|wss):\/\//,"");if(n.endsWith("/")&&(n=n.slice(0,-1)),r&&r.startsWith("/"))throw new Error("path must not start with a slash");let p=_??"main",i=r?`/${r}`:"",g=h||(n.startsWith("localhost:")||n.startsWith("127.0.0.1:")||n.startsWith("192.168.")||n.startsWith("10.")||n.startsWith("172.")&&n.split(".")[1]>="16"&&n.split(".")[1]<="31"||n.startsWith("[::ffff:7f00:1]:")?e:e+"s"),w=`${g}://${n}/${_?`parties/${_}`:"party"}/${u}${i}`,b=(S={})=>`${w}?${new URLSearchParams([...Object.entries(s),...Object.entries(S).filter(P)])}`,C=typeof l=="function"?async()=>b(await l()):b(l);return{host:n,path:i,room:u,name:p,protocol:g,partyUrl:w,urlProvider:C}}var y=class extends f{constructor(t){let e=T(t);super(e.urlProvider,e.protocols,e.socketOptions),this.partySocketOptions=t,this.setWSProperties(e)}_pk;_pkurl;name;room;host;path;updateProperties(t){let e=T({...this.partySocketOptions,...t,host:t.host??this.host,room:t.room??this.room,path:t.path??this.path});this._url=e.urlProvider,this._protocols=e.protocols,this._options=e.socketOptions,this.setWSProperties(e)}setWSProperties(t){let{_pk:e,_pkurl:s,name:o,room:r,host:h,path:u}=t;this._pk=e,this._pkurl=s,this.name=o,this.room=r,this.host=h,this.path=u}reconnect(t,e){if(!this.room||!this.host)throw new Error("The room and host must be set before connecting, use `updateProperties` method to set them or pass them to the constructor.");super.reconnect(t,e)}get id(){return this._pk}get roomUrl(){return this._pkurl}static async fetch(t,e){let s=k(t,"http"),o=typeof s.urlProvider=="string"?s.urlProvider:await s.urlProvider();return(t.fetch??fetch)(o,e)}};function T(t){let{id:e,host:s,path:o,party:r,room:h,protocol:u,query:_,protocols:l,...n}=t,p=e||R(),i=k(t,"ws",{_pk:p});return{_pk:p,_pkurl:i.partyUrl,name:i.name,room:i.room,host:i.host,path:i.path,protocols:l,socketOptions:n,urlProvider:i.urlProvider}}var Y=new y({host:"textarea-party.israeljuri.partykit.dev",room:"my-new-room"});
/*! Bundled license information:

partysocket/dist/chunk-KZ3GGBVP.mjs:
  (*!
   * Reconnecting WebSocket
   * by Pedro Ladaria <pedro.ladaria@gmail.com>
   * https://github.com/pladaria/reconnecting-websocket
   * License MIT
   *)
*/
//# sourceMappingURL=client.js.map
