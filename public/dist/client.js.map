{
  "version": 3,
  "sources": ["../../node_modules/partysocket/dist/chunk-KZ3GGBVP.mjs", "../../node_modules/partysocket/dist/chunk-G2EOJEOR.mjs", "../../app/partykit/client.ts"],
  "sourcesContent": ["// src/ws.ts\nif (!globalThis.EventTarget || !globalThis.Event) {\n  console.error(`\n  PartySocket requires a global 'EventTarget' class to be available!\n  You can polyfill this global by adding this to your code before any partysocket imports: \n  \n  \\`\\`\\`\n  import 'partysocket/event-target-polyfill';\n  \\`\\`\\`\n  Please file an issue at https://github.com/partykit/partykit if you're still having trouble.\n`);\n}\nvar ErrorEvent = class extends Event {\n  message;\n  error;\n  constructor(error, target) {\n    super(\"error\", target);\n    this.message = error.message;\n    this.error = error;\n  }\n};\nvar CloseEvent = class extends Event {\n  code;\n  reason;\n  wasClean = true;\n  constructor(code = 1e3, reason = \"\", target) {\n    super(\"close\", target);\n    this.code = code;\n    this.reason = reason;\n  }\n};\nvar Events = {\n  Event,\n  ErrorEvent,\n  CloseEvent\n};\nfunction assert(condition, msg) {\n  if (!condition) {\n    throw new Error(msg);\n  }\n}\nfunction cloneEventBrowser(e) {\n  return new e.constructor(e.type, e);\n}\nfunction cloneEventNode(e) {\n  if (\"data\" in e) {\n    const evt2 = new MessageEvent(e.type, e);\n    return evt2;\n  }\n  if (\"code\" in e || \"reason\" in e) {\n    const evt2 = new CloseEvent(\n      // @ts-expect-error we need to fix event/listener types\n      e.code || 1999,\n      // @ts-expect-error we need to fix event/listener types\n      e.reason || \"unknown reason\",\n      e\n    );\n    return evt2;\n  }\n  if (\"error\" in e) {\n    const evt2 = new ErrorEvent(e.error, e);\n    return evt2;\n  }\n  const evt = new Event(e.type, e);\n  return evt;\n}\nvar isNode = typeof process !== \"undefined\" && typeof process.versions?.node !== \"undefined\" && typeof document === \"undefined\";\nvar cloneEvent = isNode ? cloneEventNode : cloneEventBrowser;\nvar DEFAULT = {\n  maxReconnectionDelay: 1e4,\n  minReconnectionDelay: 1e3 + Math.random() * 4e3,\n  minUptime: 5e3,\n  reconnectionDelayGrowFactor: 1.3,\n  connectionTimeout: 4e3,\n  maxRetries: Infinity,\n  maxEnqueuedMessages: Infinity,\n  startClosed: false,\n  debug: false\n};\nvar didWarnAboutMissingWebSocket = false;\nvar ReconnectingWebSocket = class _ReconnectingWebSocket extends EventTarget {\n  _ws;\n  _retryCount = -1;\n  _uptimeTimeout;\n  _connectTimeout;\n  _shouldReconnect = true;\n  _connectLock = false;\n  _binaryType = \"blob\";\n  _closeCalled = false;\n  _messageQueue = [];\n  _debugLogger = console.log.bind(console);\n  _url;\n  _protocols;\n  _options;\n  constructor(url, protocols, options = {}) {\n    super();\n    this._url = url;\n    this._protocols = protocols;\n    this._options = options;\n    if (this._options.startClosed) {\n      this._shouldReconnect = false;\n    }\n    if (this._options.debugLogger) {\n      this._debugLogger = this._options.debugLogger;\n    }\n    this._connect();\n  }\n  static get CONNECTING() {\n    return 0;\n  }\n  static get OPEN() {\n    return 1;\n  }\n  static get CLOSING() {\n    return 2;\n  }\n  static get CLOSED() {\n    return 3;\n  }\n  get CONNECTING() {\n    return _ReconnectingWebSocket.CONNECTING;\n  }\n  get OPEN() {\n    return _ReconnectingWebSocket.OPEN;\n  }\n  get CLOSING() {\n    return _ReconnectingWebSocket.CLOSING;\n  }\n  get CLOSED() {\n    return _ReconnectingWebSocket.CLOSED;\n  }\n  get binaryType() {\n    return this._ws ? this._ws.binaryType : this._binaryType;\n  }\n  set binaryType(value) {\n    this._binaryType = value;\n    if (this._ws) {\n      this._ws.binaryType = value;\n    }\n  }\n  /**\n   * Returns the number or connection retries\n   */\n  get retryCount() {\n    return Math.max(this._retryCount, 0);\n  }\n  /**\n   * The number of bytes of data that have been queued using calls to send() but not yet\n   * transmitted to the network. This value resets to zero once all queued data has been sent.\n   * This value does not reset to zero when the connection is closed; if you keep calling send(),\n   * this will continue to climb. Read only\n   */\n  get bufferedAmount() {\n    const bytes = this._messageQueue.reduce((acc, message) => {\n      if (typeof message === \"string\") {\n        acc += message.length;\n      } else if (message instanceof Blob) {\n        acc += message.size;\n      } else {\n        acc += message.byteLength;\n      }\n      return acc;\n    }, 0);\n    return bytes + (this._ws ? this._ws.bufferedAmount : 0);\n  }\n  /**\n   * The extensions selected by the server. This is currently only the empty string or a list of\n   * extensions as negotiated by the connection\n   */\n  get extensions() {\n    return this._ws ? this._ws.extensions : \"\";\n  }\n  /**\n   * A string indicating the name of the sub-protocol the server selected;\n   * this will be one of the strings specified in the protocols parameter when creating the\n   * WebSocket object\n   */\n  get protocol() {\n    return this._ws ? this._ws.protocol : \"\";\n  }\n  /**\n   * The current state of the connection; this is one of the Ready state constants\n   */\n  get readyState() {\n    if (this._ws) {\n      return this._ws.readyState;\n    }\n    return this._options.startClosed ? _ReconnectingWebSocket.CLOSED : _ReconnectingWebSocket.CONNECTING;\n  }\n  /**\n   * The URL as resolved by the constructor\n   */\n  get url() {\n    return this._ws ? this._ws.url : \"\";\n  }\n  /**\n   * Whether the websocket object is now in reconnectable state\n   */\n  get shouldReconnect() {\n    return this._shouldReconnect;\n  }\n  /**\n   * An event listener to be called when the WebSocket connection's readyState changes to CLOSED\n   */\n  onclose = null;\n  /**\n   * An event listener to be called when an error occurs\n   */\n  onerror = null;\n  /**\n   * An event listener to be called when a message is received from the server\n   */\n  onmessage = null;\n  /**\n   * An event listener to be called when the WebSocket connection's readyState changes to OPEN;\n   * this indicates that the connection is ready to send and receive data\n   */\n  onopen = null;\n  /**\n   * Closes the WebSocket connection or connection attempt, if any. If the connection is already\n   * CLOSED, this method does nothing\n   */\n  close(code = 1e3, reason) {\n    this._closeCalled = true;\n    this._shouldReconnect = false;\n    this._clearTimeouts();\n    if (!this._ws) {\n      this._debug(\"close enqueued: no ws instance\");\n      return;\n    }\n    if (this._ws.readyState === this.CLOSED) {\n      this._debug(\"close: already closed\");\n      return;\n    }\n    this._ws.close(code, reason);\n  }\n  /**\n   * Closes the WebSocket connection or connection attempt and connects again.\n   * Resets retry counter;\n   */\n  reconnect(code, reason) {\n    this._shouldReconnect = true;\n    this._closeCalled = false;\n    this._retryCount = -1;\n    if (!this._ws || this._ws.readyState === this.CLOSED) {\n      this._connect();\n    } else {\n      this._disconnect(code, reason);\n      this._connect();\n    }\n  }\n  /**\n   * Enqueue specified data to be transmitted to the server over the WebSocket connection\n   */\n  send(data) {\n    if (this._ws && this._ws.readyState === this.OPEN) {\n      this._debug(\"send\", data);\n      this._ws.send(data);\n    } else {\n      const { maxEnqueuedMessages = DEFAULT.maxEnqueuedMessages } = this._options;\n      if (this._messageQueue.length < maxEnqueuedMessages) {\n        this._debug(\"enqueue\", data);\n        this._messageQueue.push(data);\n      }\n    }\n  }\n  _debug(...args) {\n    if (this._options.debug) {\n      this._debugLogger(\"RWS>\", ...args);\n    }\n  }\n  _getNextDelay() {\n    const {\n      reconnectionDelayGrowFactor = DEFAULT.reconnectionDelayGrowFactor,\n      minReconnectionDelay = DEFAULT.minReconnectionDelay,\n      maxReconnectionDelay = DEFAULT.maxReconnectionDelay\n    } = this._options;\n    let delay = 0;\n    if (this._retryCount > 0) {\n      delay = minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);\n      if (delay > maxReconnectionDelay) {\n        delay = maxReconnectionDelay;\n      }\n    }\n    this._debug(\"next delay\", delay);\n    return delay;\n  }\n  _wait() {\n    return new Promise((resolve) => {\n      setTimeout(resolve, this._getNextDelay());\n    });\n  }\n  _getNextProtocols(protocolsProvider) {\n    if (!protocolsProvider)\n      return Promise.resolve(null);\n    if (typeof protocolsProvider === \"string\" || Array.isArray(protocolsProvider)) {\n      return Promise.resolve(protocolsProvider);\n    }\n    if (typeof protocolsProvider === \"function\") {\n      const protocols = protocolsProvider();\n      if (!protocols)\n        return Promise.resolve(null);\n      if (typeof protocols === \"string\" || Array.isArray(protocols)) {\n        return Promise.resolve(protocols);\n      }\n      if (protocols.then) {\n        return protocols;\n      }\n    }\n    throw Error(\"Invalid protocols\");\n  }\n  _getNextUrl(urlProvider) {\n    if (typeof urlProvider === \"string\") {\n      return Promise.resolve(urlProvider);\n    }\n    if (typeof urlProvider === \"function\") {\n      const url = urlProvider();\n      if (typeof url === \"string\") {\n        return Promise.resolve(url);\n      }\n      if (url.then) {\n        return url;\n      }\n    }\n    throw Error(\"Invalid URL\");\n  }\n  _connect() {\n    if (this._connectLock || !this._shouldReconnect) {\n      return;\n    }\n    this._connectLock = true;\n    const {\n      maxRetries = DEFAULT.maxRetries,\n      connectionTimeout = DEFAULT.connectionTimeout\n    } = this._options;\n    if (this._retryCount >= maxRetries) {\n      this._debug(\"max retries reached\", this._retryCount, \">=\", maxRetries);\n      return;\n    }\n    this._retryCount++;\n    this._debug(\"connect\", this._retryCount);\n    this._removeListeners();\n    this._wait().then(\n      () => Promise.all([\n        this._getNextUrl(this._url),\n        this._getNextProtocols(this._protocols || null)\n      ])\n    ).then(([url, protocols]) => {\n      if (this._closeCalled) {\n        this._connectLock = false;\n        return;\n      }\n      if (!this._options.WebSocket && typeof WebSocket === \"undefined\" && !didWarnAboutMissingWebSocket) {\n        console.error(`\\u203C\\uFE0F No WebSocket implementation available. You should define options.WebSocket. \n\nFor example, if you're using node.js, run \\`npm install ws\\`, and then in your code:\n\nimport PartySocket from 'partysocket';\nimport WS from 'ws';\n\nconst partysocket = new PartySocket({\n  host: \"127.0.0.1:1999\",\n  room: \"test-room\",\n  WebSocket: WS\n});\n\n`);\n        didWarnAboutMissingWebSocket = true;\n      }\n      const WS = this._options.WebSocket || WebSocket;\n      this._debug(\"connect\", { url, protocols });\n      this._ws = protocols ? new WS(url, protocols) : new WS(url);\n      this._ws.binaryType = this._binaryType;\n      this._connectLock = false;\n      this._addListeners();\n      this._connectTimeout = setTimeout(\n        () => this._handleTimeout(),\n        connectionTimeout\n      );\n    }).catch((err) => {\n      this._connectLock = false;\n      this._handleError(new Events.ErrorEvent(Error(err.message), this));\n    });\n  }\n  _handleTimeout() {\n    this._debug(\"timeout event\");\n    this._handleError(new Events.ErrorEvent(Error(\"TIMEOUT\"), this));\n  }\n  _disconnect(code = 1e3, reason) {\n    this._clearTimeouts();\n    if (!this._ws) {\n      return;\n    }\n    this._removeListeners();\n    try {\n      this._ws.close(code, reason);\n      this._handleClose(new Events.CloseEvent(code, reason, this));\n    } catch (error) {\n    }\n  }\n  _acceptOpen() {\n    this._debug(\"accept open\");\n    this._retryCount = 0;\n  }\n  _handleOpen = (event) => {\n    this._debug(\"open event\");\n    const { minUptime = DEFAULT.minUptime } = this._options;\n    clearTimeout(this._connectTimeout);\n    this._uptimeTimeout = setTimeout(() => this._acceptOpen(), minUptime);\n    assert(this._ws, \"WebSocket is not defined\");\n    this._ws.binaryType = this._binaryType;\n    this._messageQueue.forEach((message) => this._ws?.send(message));\n    this._messageQueue = [];\n    if (this.onopen) {\n      this.onopen(event);\n    }\n    this.dispatchEvent(cloneEvent(event));\n  };\n  _handleMessage = (event) => {\n    this._debug(\"message event\");\n    if (this.onmessage) {\n      this.onmessage(event);\n    }\n    this.dispatchEvent(cloneEvent(event));\n  };\n  _handleError = (event) => {\n    this._debug(\"error event\", event.message);\n    this._disconnect(\n      void 0,\n      event.message === \"TIMEOUT\" ? \"timeout\" : void 0\n    );\n    if (this.onerror) {\n      this.onerror(event);\n    }\n    this._debug(\"exec error listeners\");\n    this.dispatchEvent(cloneEvent(event));\n    this._connect();\n  };\n  _handleClose = (event) => {\n    this._debug(\"close event\");\n    this._clearTimeouts();\n    if (this._shouldReconnect) {\n      this._connect();\n    }\n    if (this.onclose) {\n      this.onclose(event);\n    }\n    this.dispatchEvent(cloneEvent(event));\n  };\n  _removeListeners() {\n    if (!this._ws) {\n      return;\n    }\n    this._debug(\"removeListeners\");\n    this._ws.removeEventListener(\"open\", this._handleOpen);\n    this._ws.removeEventListener(\"close\", this._handleClose);\n    this._ws.removeEventListener(\"message\", this._handleMessage);\n    this._ws.removeEventListener(\"error\", this._handleError);\n  }\n  _addListeners() {\n    if (!this._ws) {\n      return;\n    }\n    this._debug(\"addListeners\");\n    this._ws.addEventListener(\"open\", this._handleOpen);\n    this._ws.addEventListener(\"close\", this._handleClose);\n    this._ws.addEventListener(\"message\", this._handleMessage);\n    this._ws.addEventListener(\"error\", this._handleError);\n  }\n  _clearTimeouts() {\n    clearTimeout(this._connectTimeout);\n    clearTimeout(this._uptimeTimeout);\n  }\n};\n\nexport {\n  ErrorEvent,\n  CloseEvent,\n  ReconnectingWebSocket\n};\n/*!\n * Reconnecting WebSocket\n * by Pedro Ladaria <pedro.ladaria@gmail.com>\n * https://github.com/pladaria/reconnecting-websocket\n * License MIT\n */\n", "import {\n  ReconnectingWebSocket\n} from \"./chunk-KZ3GGBVP.mjs\";\n\n// src/index.ts\nvar valueIsNotNil = (keyValuePair) => keyValuePair[1] !== null && keyValuePair[1] !== void 0;\nfunction generateUUID() {\n  if (typeof crypto !== \"undefined\" && crypto.randomUUID) {\n    return crypto.randomUUID();\n  }\n  let d = (/* @__PURE__ */ new Date()).getTime();\n  let d2 = typeof performance !== \"undefined\" && performance.now && performance.now() * 1e3 || 0;\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n    let r = Math.random() * 16;\n    if (d > 0) {\n      r = (d + r) % 16 | 0;\n      d = Math.floor(d / 16);\n    } else {\n      r = (d2 + r) % 16 | 0;\n      d2 = Math.floor(d2 / 16);\n    }\n    return (c === \"x\" ? r : r & 3 | 8).toString(16);\n  });\n}\nfunction getPartyInfo(partySocketOptions, defaultProtocol, defaultParams = {}) {\n  const {\n    host: rawHost,\n    path: rawPath,\n    protocol: rawProtocol,\n    room,\n    party,\n    query\n  } = partySocketOptions;\n  let host = rawHost.replace(/^(http|https|ws|wss):\\/\\//, \"\");\n  if (host.endsWith(\"/\")) {\n    host = host.slice(0, -1);\n  }\n  if (rawPath && rawPath.startsWith(\"/\")) {\n    throw new Error(\"path must not start with a slash\");\n  }\n  const name = party ?? \"main\";\n  const path = rawPath ? `/${rawPath}` : \"\";\n  const protocol = rawProtocol || (host.startsWith(\"localhost:\") || host.startsWith(\"127.0.0.1:\") || host.startsWith(\"192.168.\") || host.startsWith(\"10.\") || host.startsWith(\"172.\") && host.split(\".\")[1] >= \"16\" && host.split(\".\")[1] <= \"31\" || host.startsWith(\"[::ffff:7f00:1]:\") ? (\n    // http / ws\n    defaultProtocol\n  ) : (\n    // https / wss\n    defaultProtocol + \"s\"\n  ));\n  const baseUrl = `${protocol}://${host}/${party ? `parties/${party}` : \"party\"}/${room}${path}`;\n  const makeUrl = (query2 = {}) => `${baseUrl}?${new URLSearchParams([\n    ...Object.entries(defaultParams),\n    ...Object.entries(query2).filter(valueIsNotNil)\n  ])}`;\n  const urlProvider = typeof query === \"function\" ? async () => makeUrl(await query()) : makeUrl(query);\n  return {\n    host,\n    path,\n    room,\n    name,\n    protocol,\n    partyUrl: baseUrl,\n    urlProvider\n  };\n}\nvar PartySocket = class extends ReconnectingWebSocket {\n  constructor(partySocketOptions) {\n    const wsOptions = getWSOptions(partySocketOptions);\n    super(wsOptions.urlProvider, wsOptions.protocols, wsOptions.socketOptions);\n    this.partySocketOptions = partySocketOptions;\n    this.setWSProperties(wsOptions);\n  }\n  _pk;\n  _pkurl;\n  name;\n  room;\n  host;\n  path;\n  updateProperties(partySocketOptions) {\n    const wsOptions = getWSOptions({\n      ...this.partySocketOptions,\n      ...partySocketOptions,\n      host: partySocketOptions.host ?? this.host,\n      room: partySocketOptions.room ?? this.room,\n      path: partySocketOptions.path ?? this.path\n    });\n    this._url = wsOptions.urlProvider;\n    this._protocols = wsOptions.protocols;\n    this._options = wsOptions.socketOptions;\n    this.setWSProperties(wsOptions);\n  }\n  setWSProperties(wsOptions) {\n    const { _pk, _pkurl, name, room, host, path } = wsOptions;\n    this._pk = _pk;\n    this._pkurl = _pkurl;\n    this.name = name;\n    this.room = room;\n    this.host = host;\n    this.path = path;\n  }\n  reconnect(code, reason) {\n    if (!this.room || !this.host) {\n      throw new Error(\n        \"The room and host must be set before connecting, use `updateProperties` method to set them or pass them to the constructor.\"\n      );\n    }\n    super.reconnect(code, reason);\n  }\n  get id() {\n    return this._pk;\n  }\n  /**\n   * Exposes the static PartyKit room URL without applying query parameters.\n   * To access the currently connected WebSocket url, use PartySocket#url.\n   */\n  get roomUrl() {\n    return this._pkurl;\n  }\n  // a `fetch` method that uses (almost) the same options as `PartySocket`\n  static async fetch(options, init) {\n    const party = getPartyInfo(options, \"http\");\n    const url = typeof party.urlProvider === \"string\" ? party.urlProvider : await party.urlProvider();\n    const doFetch = options.fetch ?? fetch;\n    return doFetch(url, init);\n  }\n};\nfunction getWSOptions(partySocketOptions) {\n  const {\n    id,\n    host: _host,\n    path: _path,\n    party: _party,\n    room: _room,\n    protocol: _protocol,\n    query: _query,\n    protocols,\n    ...socketOptions\n  } = partySocketOptions;\n  const _pk = id || generateUUID();\n  const party = getPartyInfo(partySocketOptions, \"ws\", { _pk });\n  return {\n    _pk,\n    _pkurl: party.partyUrl,\n    name: party.name,\n    room: party.room,\n    host: party.host,\n    path: party.path,\n    protocols,\n    socketOptions,\n    urlProvider: party.urlProvider\n  };\n}\n\nexport {\n  PartySocket\n};\n", "// import './styles.css';\n\nimport PartySocket from 'partysocket';\n\ndeclare const PARTYKIT_HOST: string;\n\n// let pingInterval: ReturnType<typeof setInterval>;\n\n// Let's append all the messages we get into this DOM element\n// const output = document.getElementById('app') as HTMLDivElement;\n\n// Helper function to add a new line to the DOM\n// function add(text: string) {\n//   output.appendChild(document.createTextNode(text));\n//   output.appendChild(document.createElement('br'));\n// }\n\n// A PartySocket is like a WebSocket, except it's a bit more magical.\n// It handles reconnection logic, buffering messages while it's offline, and more.\nconst conn = new PartySocket({\n  host: PARTYKIT_HOST,\n  room: 'my-new-room',\n});\n\n// You can even start sending messages before the connection is open!\n// conn.addEventListener('message', (event) => {\n//   add(`Received -> ${event.data}`);\n// });\n\n// Let's listen for when the connection opens\n// And send a ping every 2 seconds right after\n// conn.addEventListener(\"open\", () => {\n//   add(\"Connected!\");\n//   add(\"Sending a ping every 2 seconds...\");\n//   // TODO: make this more interesting / nice\n//   // clearInterval(pingInterval);\n//   // pingInterval = setInterval(() => {\n//   //   conn.send(\"ping\");\n//   // }, 1000);\n// });\n"],
  "mappings": "CACI,CAAC,WAAW,aAAe,CAAC,WAAW,QACzC,QAAQ,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAQf,EAED,IAAIA,EAAa,cAAc,KAAM,CACnC,QACA,MACA,YAAYC,EAAOC,EAAQ,CACzB,MAAM,QAASA,CAAM,EACrB,KAAK,QAAUD,EAAM,QACrB,KAAK,MAAQA,CACf,CACF,EACIE,EAAa,cAAc,KAAM,CACnC,KACA,OACA,SAAW,GACX,YAAYC,EAAO,IAAKC,EAAS,GAAIH,EAAQ,CAC3C,MAAM,QAASA,CAAM,EACrB,KAAK,KAAOE,EACZ,KAAK,OAASC,CAChB,CACF,EACIC,EAAS,CACX,MACA,WAAAN,EACA,WAAAG,CACF,EACA,SAASI,EAAOC,EAAWC,EAAK,CAC9B,GAAI,CAACD,EACH,MAAM,IAAI,MAAMC,CAAG,CAEvB,CACA,SAASC,EAAkBC,EAAG,CAC5B,OAAO,IAAIA,EAAE,YAAYA,EAAE,KAAMA,CAAC,CACpC,CACA,SAASC,EAAeD,EAAG,CACzB,MAAI,SAAUA,EACC,IAAI,aAAaA,EAAE,KAAMA,CAAC,EAGrC,SAAUA,GAAK,WAAYA,EAChB,IAAIR,EAEfQ,EAAE,MAAQ,KAEVA,EAAE,QAAU,iBACZA,CACF,EAGE,UAAWA,EACA,IAAIX,EAAWW,EAAE,MAAOA,CAAC,EAG5B,IAAI,MAAMA,EAAE,KAAMA,CAAC,CAEjC,CACA,IAAIE,EAAS,OAAO,QAAY,KAAe,OAAO,QAAQ,UAAU,KAAS,KAAe,OAAO,SAAa,IAChHC,EAAaD,EAASD,EAAiBF,EACvCK,EAAU,CACZ,qBAAsB,IACtB,qBAAsB,IAAM,KAAK,OAAO,EAAI,IAC5C,UAAW,IACX,4BAA6B,IAC7B,kBAAmB,IACnB,WAAY,IACZ,oBAAqB,IACrB,YAAa,GACb,MAAO,EACT,EACIC,EAA+B,GAC/BC,EAAwB,MAAMC,UAA+B,WAAY,CAC3E,IACA,YAAc,GACd,eACA,gBACA,iBAAmB,GACnB,aAAe,GACf,YAAc,OACd,aAAe,GACf,cAAgB,CAAC,EACjB,aAAe,QAAQ,IAAI,KAAK,OAAO,EACvC,KACA,WACA,SACA,YAAYC,EAAKC,EAAWC,EAAU,CAAC,EAAG,CACxC,MAAM,EACN,KAAK,KAAOF,EACZ,KAAK,WAAaC,EAClB,KAAK,SAAWC,EACZ,KAAK,SAAS,cAChB,KAAK,iBAAmB,IAEtB,KAAK,SAAS,cAChB,KAAK,aAAe,KAAK,SAAS,aAEpC,KAAK,SAAS,CAChB,CACA,WAAW,YAAa,CACtB,MAAO,EACT,CACA,WAAW,MAAO,CAChB,MAAO,EACT,CACA,WAAW,SAAU,CACnB,MAAO,EACT,CACA,WAAW,QAAS,CAClB,MAAO,EACT,CACA,IAAI,YAAa,CACf,OAAOH,EAAuB,UAChC,CACA,IAAI,MAAO,CACT,OAAOA,EAAuB,IAChC,CACA,IAAI,SAAU,CACZ,OAAOA,EAAuB,OAChC,CACA,IAAI,QAAS,CACX,OAAOA,EAAuB,MAChC,CACA,IAAI,YAAa,CACf,OAAO,KAAK,IAAM,KAAK,IAAI,WAAa,KAAK,WAC/C,CACA,IAAI,WAAWI,EAAO,CACpB,KAAK,YAAcA,EACf,KAAK,MACP,KAAK,IAAI,WAAaA,EAE1B,CAIA,IAAI,YAAa,CACf,OAAO,KAAK,IAAI,KAAK,YAAa,CAAC,CACrC,CAOA,IAAI,gBAAiB,CAWnB,OAVc,KAAK,cAAc,OAAO,CAACC,EAAKC,KACxC,OAAOA,GAAY,SACrBD,GAAOC,EAAQ,OACNA,aAAmB,KAC5BD,GAAOC,EAAQ,KAEfD,GAAOC,EAAQ,WAEVD,GACN,CAAC,GACY,KAAK,IAAM,KAAK,IAAI,eAAiB,EACvD,CAKA,IAAI,YAAa,CACf,OAAO,KAAK,IAAM,KAAK,IAAI,WAAa,EAC1C,CAMA,IAAI,UAAW,CACb,OAAO,KAAK,IAAM,KAAK,IAAI,SAAW,EACxC,CAIA,IAAI,YAAa,CACf,OAAI,KAAK,IACA,KAAK,IAAI,WAEX,KAAK,SAAS,YAAcL,EAAuB,OAASA,EAAuB,UAC5F,CAIA,IAAI,KAAM,CACR,OAAO,KAAK,IAAM,KAAK,IAAI,IAAM,EACnC,CAIA,IAAI,iBAAkB,CACpB,OAAO,KAAK,gBACd,CAIA,QAAU,KAIV,QAAU,KAIV,UAAY,KAKZ,OAAS,KAKT,MAAMd,EAAO,IAAKC,EAAQ,CAIxB,GAHA,KAAK,aAAe,GACpB,KAAK,iBAAmB,GACxB,KAAK,eAAe,EAChB,CAAC,KAAK,IAAK,CACb,KAAK,OAAO,gCAAgC,EAC5C,MACF,CACA,GAAI,KAAK,IAAI,aAAe,KAAK,OAAQ,CACvC,KAAK,OAAO,uBAAuB,EACnC,MACF,CACA,KAAK,IAAI,MAAMD,EAAMC,CAAM,CAC7B,CAKA,UAAUD,EAAMC,EAAQ,CACtB,KAAK,iBAAmB,GACxB,KAAK,aAAe,GACpB,KAAK,YAAc,GACf,CAAC,KAAK,KAAO,KAAK,IAAI,aAAe,KAAK,OAC5C,KAAK,SAAS,GAEd,KAAK,YAAYD,EAAMC,CAAM,EAC7B,KAAK,SAAS,EAElB,CAIA,KAAKoB,EAAM,CACT,GAAI,KAAK,KAAO,KAAK,IAAI,aAAe,KAAK,KAC3C,KAAK,OAAO,OAAQA,CAAI,EACxB,KAAK,IAAI,KAAKA,CAAI,MACb,CACL,GAAM,CAAE,oBAAAC,EAAsBX,EAAQ,mBAAoB,EAAI,KAAK,SAC/D,KAAK,cAAc,OAASW,IAC9B,KAAK,OAAO,UAAWD,CAAI,EAC3B,KAAK,cAAc,KAAKA,CAAI,EAEhC,CACF,CACA,UAAUE,EAAM,CACV,KAAK,SAAS,OAChB,KAAK,aAAa,OAAQ,GAAGA,CAAI,CAErC,CACA,eAAgB,CACd,GAAM,CACJ,4BAAAC,EAA8Bb,EAAQ,4BACtC,qBAAAc,EAAuBd,EAAQ,qBAC/B,qBAAAe,EAAuBf,EAAQ,oBACjC,EAAI,KAAK,SACLgB,EAAQ,EACZ,OAAI,KAAK,YAAc,IACrBA,EAAQF,EAAuB,KAAK,IAAID,EAA6B,KAAK,YAAc,CAAC,EACrFG,EAAQD,IACVC,EAAQD,IAGZ,KAAK,OAAO,aAAcC,CAAK,EACxBA,CACT,CACA,OAAQ,CACN,OAAO,IAAI,QAASC,GAAY,CAC9B,WAAWA,EAAS,KAAK,cAAc,CAAC,CAC1C,CAAC,CACH,CACA,kBAAkBC,EAAmB,CACnC,GAAI,CAACA,EACH,OAAO,QAAQ,QAAQ,IAAI,EAC7B,GAAI,OAAOA,GAAsB,UAAY,MAAM,QAAQA,CAAiB,EAC1E,OAAO,QAAQ,QAAQA,CAAiB,EAE1C,GAAI,OAAOA,GAAsB,WAAY,CAC3C,IAAMb,EAAYa,EAAkB,EACpC,GAAI,CAACb,EACH,OAAO,QAAQ,QAAQ,IAAI,EAC7B,GAAI,OAAOA,GAAc,UAAY,MAAM,QAAQA,CAAS,EAC1D,OAAO,QAAQ,QAAQA,CAAS,EAElC,GAAIA,EAAU,KACZ,OAAOA,CAEX,CACA,MAAM,MAAM,mBAAmB,CACjC,CACA,YAAYc,EAAa,CACvB,GAAI,OAAOA,GAAgB,SACzB,OAAO,QAAQ,QAAQA,CAAW,EAEpC,GAAI,OAAOA,GAAgB,WAAY,CACrC,IAAMf,EAAMe,EAAY,EACxB,GAAI,OAAOf,GAAQ,SACjB,OAAO,QAAQ,QAAQA,CAAG,EAE5B,GAAIA,EAAI,KACN,OAAOA,CAEX,CACA,MAAM,MAAM,aAAa,CAC3B,CACA,UAAW,CACT,GAAI,KAAK,cAAgB,CAAC,KAAK,iBAC7B,OAEF,KAAK,aAAe,GACpB,GAAM,CACJ,WAAAgB,EAAapB,EAAQ,WACrB,kBAAAqB,EAAoBrB,EAAQ,iBAC9B,EAAI,KAAK,SACT,GAAI,KAAK,aAAeoB,EAAY,CAClC,KAAK,OAAO,sBAAuB,KAAK,YAAa,KAAMA,CAAU,EACrE,MACF,CACA,KAAK,cACL,KAAK,OAAO,UAAW,KAAK,WAAW,EACvC,KAAK,iBAAiB,EACtB,KAAK,MAAM,EAAE,KACX,IAAM,QAAQ,IAAI,CAChB,KAAK,YAAY,KAAK,IAAI,EAC1B,KAAK,kBAAkB,KAAK,YAAc,IAAI,CAChD,CAAC,CACH,EAAE,KAAK,CAAC,CAAChB,EAAKC,CAAS,IAAM,CAC3B,GAAI,KAAK,aAAc,CACrB,KAAK,aAAe,GACpB,MACF,CACI,CAAC,KAAK,SAAS,WAAa,OAAO,UAAc,KAAe,CAACJ,IACnE,QAAQ,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAarB,EACOA,EAA+B,IAEjC,IAAMqB,EAAK,KAAK,SAAS,WAAa,UACtC,KAAK,OAAO,UAAW,CAAE,IAAAlB,EAAK,UAAAC,CAAU,CAAC,EACzC,KAAK,IAAMA,EAAY,IAAIiB,EAAGlB,EAAKC,CAAS,EAAI,IAAIiB,EAAGlB,CAAG,EAC1D,KAAK,IAAI,WAAa,KAAK,YAC3B,KAAK,aAAe,GACpB,KAAK,cAAc,EACnB,KAAK,gBAAkB,WACrB,IAAM,KAAK,eAAe,EAC1BiB,CACF,CACF,CAAC,EAAE,MAAOE,GAAQ,CAChB,KAAK,aAAe,GACpB,KAAK,aAAa,IAAIhC,EAAO,WAAW,MAAMgC,EAAI,OAAO,EAAG,IAAI,CAAC,CACnE,CAAC,CACH,CACA,gBAAiB,CACf,KAAK,OAAO,eAAe,EAC3B,KAAK,aAAa,IAAIhC,EAAO,WAAW,MAAM,SAAS,EAAG,IAAI,CAAC,CACjE,CACA,YAAYF,EAAO,IAAKC,EAAQ,CAE9B,GADA,KAAK,eAAe,EAChB,EAAC,KAAK,IAGV,MAAK,iBAAiB,EACtB,GAAI,CACF,KAAK,IAAI,MAAMD,EAAMC,CAAM,EAC3B,KAAK,aAAa,IAAIC,EAAO,WAAWF,EAAMC,EAAQ,IAAI,CAAC,CAC7D,MAAgB,CAChB,EACF,CACA,aAAc,CACZ,KAAK,OAAO,aAAa,EACzB,KAAK,YAAc,CACrB,CACA,YAAekC,GAAU,CACvB,KAAK,OAAO,YAAY,EACxB,GAAM,CAAE,UAAAC,EAAYzB,EAAQ,SAAU,EAAI,KAAK,SAC/C,aAAa,KAAK,eAAe,EACjC,KAAK,eAAiB,WAAW,IAAM,KAAK,YAAY,EAAGyB,CAAS,EACpEjC,EAAO,KAAK,IAAK,0BAA0B,EAC3C,KAAK,IAAI,WAAa,KAAK,YAC3B,KAAK,cAAc,QAASiB,GAAY,KAAK,KAAK,KAAKA,CAAO,CAAC,EAC/D,KAAK,cAAgB,CAAC,EAClB,KAAK,QACP,KAAK,OAAOe,CAAK,EAEnB,KAAK,cAAczB,EAAWyB,CAAK,CAAC,CACtC,EACA,eAAkBA,GAAU,CAC1B,KAAK,OAAO,eAAe,EACvB,KAAK,WACP,KAAK,UAAUA,CAAK,EAEtB,KAAK,cAAczB,EAAWyB,CAAK,CAAC,CACtC,EACA,aAAgBA,GAAU,CACxB,KAAK,OAAO,cAAeA,EAAM,OAAO,EACxC,KAAK,YACH,OACAA,EAAM,UAAY,UAAY,UAAY,MAC5C,EACI,KAAK,SACP,KAAK,QAAQA,CAAK,EAEpB,KAAK,OAAO,sBAAsB,EAClC,KAAK,cAAczB,EAAWyB,CAAK,CAAC,EACpC,KAAK,SAAS,CAChB,EACA,aAAgBA,GAAU,CACxB,KAAK,OAAO,aAAa,EACzB,KAAK,eAAe,EAChB,KAAK,kBACP,KAAK,SAAS,EAEZ,KAAK,SACP,KAAK,QAAQA,CAAK,EAEpB,KAAK,cAAczB,EAAWyB,CAAK,CAAC,CACtC,EACA,kBAAmB,CACZ,KAAK,MAGV,KAAK,OAAO,iBAAiB,EAC7B,KAAK,IAAI,oBAAoB,OAAQ,KAAK,WAAW,EACrD,KAAK,IAAI,oBAAoB,QAAS,KAAK,YAAY,EACvD,KAAK,IAAI,oBAAoB,UAAW,KAAK,cAAc,EAC3D,KAAK,IAAI,oBAAoB,QAAS,KAAK,YAAY,EACzD,CACA,eAAgB,CACT,KAAK,MAGV,KAAK,OAAO,cAAc,EAC1B,KAAK,IAAI,iBAAiB,OAAQ,KAAK,WAAW,EAClD,KAAK,IAAI,iBAAiB,QAAS,KAAK,YAAY,EACpD,KAAK,IAAI,iBAAiB,UAAW,KAAK,cAAc,EACxD,KAAK,IAAI,iBAAiB,QAAS,KAAK,YAAY,EACtD,CACA,gBAAiB,CACf,aAAa,KAAK,eAAe,EACjC,aAAa,KAAK,cAAc,CAClC,CACF,ECpdA,IAAIE,EAAiBC,GAAiBA,EAAa,CAAC,IAAM,MAAQA,EAAa,CAAC,IAAM,OACtF,SAASC,GAAe,CACtB,GAAI,OAAO,OAAW,KAAe,OAAO,WAC1C,OAAO,OAAO,WAAW,EAE3B,IAAIC,EAAqB,IAAI,KAAK,EAAG,QAAQ,EACzCC,EAAK,OAAO,YAAgB,KAAe,YAAY,KAAO,YAAY,IAAI,EAAI,KAAO,EAC7F,MAAO,uCAAuC,QAAQ,QAAS,SAASC,EAAG,CACzE,IAAIC,EAAI,KAAK,OAAO,EAAI,GACxB,OAAIH,EAAI,GACNG,GAAKH,EAAIG,GAAK,GAAK,EACnBH,EAAI,KAAK,MAAMA,EAAI,EAAE,IAErBG,GAAKF,EAAKE,GAAK,GAAK,EACpBF,EAAK,KAAK,MAAMA,EAAK,EAAE,IAEjBC,IAAM,IAAMC,EAAIA,EAAI,EAAI,GAAG,SAAS,EAAE,CAChD,CAAC,CACH,CACA,SAASC,EAAaC,EAAoBC,EAAiBC,EAAgB,CAAC,EAAG,CAC7E,GAAM,CACJ,KAAMC,EACN,KAAMC,EACN,SAAUC,EACV,KAAAC,EACA,MAAAC,EACA,MAAAC,CACF,EAAIR,EACAS,EAAON,EAAQ,QAAQ,4BAA6B,EAAE,EAI1D,GAHIM,EAAK,SAAS,GAAG,IACnBA,EAAOA,EAAK,MAAM,EAAG,EAAE,GAErBL,GAAWA,EAAQ,WAAW,GAAG,EACnC,MAAM,IAAI,MAAM,kCAAkC,EAEpD,IAAMM,EAAOH,GAAS,OAChBI,EAAOP,EAAU,IAAIA,CAAO,GAAK,GACjCQ,EAAWP,IAAgBI,EAAK,WAAW,YAAY,GAAKA,EAAK,WAAW,YAAY,GAAKA,EAAK,WAAW,UAAU,GAAKA,EAAK,WAAW,KAAK,GAAKA,EAAK,WAAW,MAAM,GAAKA,EAAK,MAAM,GAAG,EAAE,CAAC,GAAK,MAAQA,EAAK,MAAM,GAAG,EAAE,CAAC,GAAK,MAAQA,EAAK,WAAW,kBAAkB,EAEnRR,EAGAA,EAAkB,KAEdY,EAAU,GAAGD,CAAQ,MAAMH,CAAI,IAAIF,EAAQ,WAAWA,CAAK,GAAK,OAAO,IAAID,CAAI,GAAGK,CAAI,GACtFG,EAAU,CAACC,EAAS,CAAC,IAAM,GAAGF,CAAO,IAAI,IAAI,gBAAgB,CACjE,GAAG,OAAO,QAAQX,CAAa,EAC/B,GAAG,OAAO,QAAQa,CAAM,EAAE,OAAOvB,CAAa,CAChD,CAAC,CAAC,GACIwB,EAAc,OAAOR,GAAU,WAAa,SAAYM,EAAQ,MAAMN,EAAM,CAAC,EAAIM,EAAQN,CAAK,EACpG,MAAO,CACL,KAAAC,EACA,KAAAE,EACA,KAAAL,EACA,KAAAI,EACA,SAAAE,EACA,SAAUC,EACV,YAAAG,CACF,CACF,CACA,IAAIC,EAAc,cAAcC,CAAsB,CACpD,YAAYlB,EAAoB,CAC9B,IAAMmB,EAAYC,EAAapB,CAAkB,EACjD,MAAMmB,EAAU,YAAaA,EAAU,UAAWA,EAAU,aAAa,EACzE,KAAK,mBAAqBnB,EAC1B,KAAK,gBAAgBmB,CAAS,CAChC,CACA,IACA,OACA,KACA,KACA,KACA,KACA,iBAAiBnB,EAAoB,CACnC,IAAMmB,EAAYC,EAAa,CAC7B,GAAG,KAAK,mBACR,GAAGpB,EACH,KAAMA,EAAmB,MAAQ,KAAK,KACtC,KAAMA,EAAmB,MAAQ,KAAK,KACtC,KAAMA,EAAmB,MAAQ,KAAK,IACxC,CAAC,EACD,KAAK,KAAOmB,EAAU,YACtB,KAAK,WAAaA,EAAU,UAC5B,KAAK,SAAWA,EAAU,cAC1B,KAAK,gBAAgBA,CAAS,CAChC,CACA,gBAAgBA,EAAW,CACzB,GAAM,CAAE,IAAAE,EAAK,OAAAC,EAAQ,KAAAZ,EAAM,KAAAJ,EAAM,KAAAG,EAAM,KAAAE,CAAK,EAAIQ,EAChD,KAAK,IAAME,EACX,KAAK,OAASC,EACd,KAAK,KAAOZ,EACZ,KAAK,KAAOJ,EACZ,KAAK,KAAOG,EACZ,KAAK,KAAOE,CACd,CACA,UAAUY,EAAMC,EAAQ,CACtB,GAAI,CAAC,KAAK,MAAQ,CAAC,KAAK,KACtB,MAAM,IAAI,MACR,6HACF,EAEF,MAAM,UAAUD,EAAMC,CAAM,CAC9B,CACA,IAAI,IAAK,CACP,OAAO,KAAK,GACd,CAKA,IAAI,SAAU,CACZ,OAAO,KAAK,MACd,CAEA,aAAa,MAAMC,EAASC,EAAM,CAChC,IAAMnB,EAAQR,EAAa0B,EAAS,MAAM,EACpCE,EAAM,OAAOpB,EAAM,aAAgB,SAAWA,EAAM,YAAc,MAAMA,EAAM,YAAY,EAEhG,OADgBkB,EAAQ,OAAS,OAClBE,EAAKD,CAAI,CAC1B,CACF,EACA,SAASN,EAAapB,EAAoB,CACxC,GAAM,CACJ,GAAA4B,EACA,KAAMC,EACN,KAAMC,EACN,MAAOC,EACP,KAAMC,EACN,SAAUC,EACV,MAAOC,EACP,UAAAC,EACA,GAAGC,CACL,EAAIpC,EACEqB,EAAMO,GAAMlC,EAAa,EACzBa,EAAQR,EAAaC,EAAoB,KAAM,CAAE,IAAAqB,CAAI,CAAC,EAC5D,MAAO,CACL,IAAAA,EACA,OAAQd,EAAM,SACd,KAAMA,EAAM,KACZ,KAAMA,EAAM,KACZ,KAAMA,EAAM,KACZ,KAAMA,EAAM,KACZ,UAAA4B,EACA,cAAAC,EACA,YAAa7B,EAAM,WACrB,CACF,CCpIA,IAAM8B,EAAO,IAAIC,EAAY,CAC3B,KAAM,yCACN,KAAM,aACR,CAAC",
  "names": ["ErrorEvent", "error", "target", "CloseEvent", "code", "reason", "Events", "assert", "condition", "msg", "cloneEventBrowser", "e", "cloneEventNode", "isNode", "cloneEvent", "DEFAULT", "didWarnAboutMissingWebSocket", "ReconnectingWebSocket", "_ReconnectingWebSocket", "url", "protocols", "options", "value", "acc", "message", "data", "maxEnqueuedMessages", "args", "reconnectionDelayGrowFactor", "minReconnectionDelay", "maxReconnectionDelay", "delay", "resolve", "protocolsProvider", "urlProvider", "maxRetries", "connectionTimeout", "WS", "err", "event", "minUptime", "valueIsNotNil", "keyValuePair", "generateUUID", "d", "d2", "c", "r", "getPartyInfo", "partySocketOptions", "defaultProtocol", "defaultParams", "rawHost", "rawPath", "rawProtocol", "room", "party", "query", "host", "name", "path", "protocol", "baseUrl", "makeUrl", "query2", "urlProvider", "PartySocket", "ReconnectingWebSocket", "wsOptions", "getWSOptions", "_pk", "_pkurl", "code", "reason", "options", "init", "url", "id", "_host", "_path", "_party", "_room", "_protocol", "_query", "protocols", "socketOptions", "conn", "PartySocket"]
}
